{
  "0": {
    "id": "0",
    "title": "Page not found",
    "content": "Page not foundThe page you requested could not be found. Try using the navigation or search to find what you're looking for or go to this site's home page.",
    "url": "/404",
    "relUrl": "/404"
  },
  "1": {
    "id": "1",
    "title": "Custom queries",
    "content": "Custom statementsYou can also issue custom queries by calling customUpdate for update and deletes andcustomSelect or customSelectStream for select statements. Using the todo exampleabove, here is a simple custom query that loads all categories and how many items arein each category:class CategoryWithCount {  final Category category;  final int count; // amount of entries in this category  CategoryWithCount(this.category, this.count);}// then, in the database class:Stream&amp;lt;List&amp;lt;CategoryWithCount&amp;gt;&amp;gt; categoriesWithCount() {    // select all categories and load how many associated entries there are for    // each category    return customSelectStream(        'SELECT *, (SELECT COUNT(*) FROM todos WHERE category = c.id) AS &quot;amount&quot; FROM categories c;',        readsFrom: {todos, categories}).map((rows) {      // when we have the result set, map each row to the data class      return rows          .map((row) =&amp;gt; CategoryWithCount(Category.fromData(row.data, this), row.readInt('amount')))          .toList();    });  }For custom selects, you should use the readsFrom parameter to specify from which tables the query isreading. When using a Stream, moor will be able to know after which updates the stream should emititems. If you’re using a custom query for updates or deletes with customUpdate, you should alsouse the updates parameter to let moor know which tables you’re touching.",
    "url": "/docs/writing_queries/custom_queries.html",
    "relUrl": "/docs/writing_queries/custom_queries.html"
  },
  "2": {
    "id": "2",
    "title": "Modularity with DAOs",
    "content": "Extracting functionality with DAOsWhen you have a lot of queries, putting them all into one class quickly becomestedious. You can avoid this by extracting some queries into classes that are available from your main database class. Consider the following code:part 'todos_dao.g.dart';// the _TodosDaoMixin will be created by moor. It contains all the necessary// fields for the tables. The &amp;lt;MyDatabase&amp;gt; type annotation is the database class// that should use this dao.@UseDao(tables: [Todos])class TodosDao extends DatabaseAccessor&amp;lt;MyDatabase&amp;gt; with _TodosDaoMixin {  // this constructor is required so that the main database can create an instance  // of this object.  TodosDao(MyDatabase db) : super(db);  Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; todosInCategory(Category category) {    if (category == null) {      return (select(todos)..where((t) =&amp;gt; isNull(t.category))).watch();    } else {      return (select(todos)..where((t) =&amp;gt; t.category.equals(category.id)))          .watch();    }  }}If we now change the annotation on the MyDatabase class to @UseMoor(tables: [Todos, Categories], daos: [TodosDao])and re-run the code generation, a generated getter todosDao can be used to access the instance of that dao.",
    "url": "/daos/",
    "relUrl": "/daos/"
  },
  "3": {
    "id": "3",
    "title": "Getting started",
    "content": "Getting startedAdding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows how your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 10)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in this readme and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with the dart build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }Congrats, you are now ready to fully use moor and write queries.",
    "url": "/getting-started/",
    "relUrl": "/getting-started/"
  },
  "4": {
    "id": "4",
    "title": "Home",
    "content": "MoorMoor is an easy to use, reactive persistence library for Flutter apps. Define yourdatabase tables in pure Dart and enjoy a fluent query API, auto-updating streamsand more!Get started nowView on GitHubGetting startedAdding the dependencyFirst, let’s add moor to your project’s pubspec.yaml.At the moment, the current version of moor_flutter is  and the current version of moor_generator is dependencies:  moor_flutter: # use the latest versiondev_dependencies:  moor_generator: # use the latest version  build_runner: We’re going to use the moor_flutter library to specify tables and access the database. Themoor_generator library will take care of generating the necessary code so thelibrary knows how your table structure looks like.Declaring tablesUsing moor, you can model the structure of your tables with simple dart code:import 'package:moor_flutter/moor_flutter.dart';// assuming that your file is called filename.dart. This will give an error at first,// but it's needed for moor to know about the generated codepart 'filename.g.dart'; // this will generate a table called &quot;todos&quot; for us. The rows of that table will// be represented by a class called &quot;Todo&quot;.class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 10)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();}// This will make moor generate a class called &quot;Category&quot; to represent a row in this table.// By default, &quot;Categorie&quot; would have been used because it only strips away the trailing &quot;s&quot;// in the table name.@DataClassName(&quot;Category&quot;)class Categories extends Table {    IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get description =&amp;gt; text()();}// this annotation tells moor to prepare a database class that uses both of the// tables we just defined. We'll see how to use that database class in a moment.@UseMoor(tables: [Todos, Categories])class MyDatabase {  }⚠️ Note: The column definitions, the table name and the primary key must be known atcompile time. For column definitions and the primary key, the function must use the =&amp;gt;operator and can’t contain anything more than what’s included in this readme and theexamples. Otherwise, the generator won’t be able to know what’s going on.Generating the codeMoor integrates with the dart build system, so you can generate all the code needed with flutter packages pub run build_runner build. If you want to continously rebuild the generated codewhever you change your code, run flutter packages pub run build_runner watch instead.After running either command once, the moor generator will have created a class for yourdatabase and data classes for your entities. To use it, change the MyDatabase class asfollows:@UseMoor(tables: [Todos, Categories])class MyDatabase extends _$MyDatabase {  // we tell the database where to store the data with this constructor  MyDatabase() : super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite'));  // you should bump this number whenever you change or add a table definition. Migrations  // are covered later in this readme.  @override  int get schemaVersion =&amp;gt; 1; }You can ignore the schemaVersion at the moment, the important part is that you cannow run your queries with fluent Dart code:TODO-List and current limitationsLimitations (at the moment)Please note that a workaround for most on this list exists with custom statements.  No group by or window functionsPlanned for the futureThese aren’t sorted by priority. If you have more ideas or want some features happening soon,let me know by creating an issue!  Simple COUNT(*) operations (group operations will be much more complicated)  Support Dart VM apps  References          DSL API      Support in generator      Validations        Bulk inserts  When inserts / updates fail due to invalid data, explain why that happened    Interesting stuff that would be nice to have    Implementing this will very likely result in backwards-incompatible changes.    Find a way to hide implementation details from users while still making themaccessible for the generated code  GROUP BY grouping functions  Support for different database engines          Support webapps via AlaSQL or a different engine      ",
    "url": "/",
    "relUrl": "/"
  },
  "5": {
    "id": "5",
    "title": "Migrations",
    "content": "MigrationsMoor provides a migration API that can be used to gradually apply schema changes after bumpingthe schemaVersion getter inside the Database class. To use it, override the migrationgetter. Here’s an example: Let’s say you wanted to add a due date to your todo entries:class Todos extends Table {  IntColumn get id =&amp;gt; integer().autoIncrement()();  TextColumn get title =&amp;gt; text().withLength(min: 6, max: 10)();  TextColumn get content =&amp;gt; text().named('body')();  IntColumn get category =&amp;gt; integer().nullable()();  DateTimeColumn get dueDate =&amp;gt; dateTime().nullable()(); // we just added this column}We can now change the database class like this:  @override  int get schemaVersion =&amp;gt; 2; // bump because the tables have changed  @override  MigrationStrategy get migration =&amp;gt; MigrationStrategy(    onCreate: (Migrator m) {      return m.createAllTables();    },    onUpgrade: (Migrator m, int from, int to) async {      if (from == 1) {        // we added the dueDate property in the change from version 1        await m.addColumn(todos, todos.dueDate);      }    }  );  // rest of class can stay the sameYou can also add individual tables or drop them. You can’t use the high-level query API inmigrations. If you need to use it, please specify the onFinished method on the MigrationStrategy. It will be called after a migration happened and it’s safe to call methodson your database from inside that method.",
    "url": "/migrations/",
    "relUrl": "/migrations/"
  },
  "6": {
    "id": "6",
    "title": "Transactions",
    "content": "TransactionsTBD",
    "url": "/docs/transactions.html",
    "relUrl": "/docs/transactions.html"
  },
  "7": {
    "id": "7",
    "title": "Writing queries",
    "content": "Note: This assumes that you already have your database class ready. Follow the instructions over here on how to do that.Writing queriesThe examples here use the tables defined here.For each table you’ve specified in the @UseMoor annotation on your database class,a corresponding getter for a table will be generated. That getter can be used torun statements:// inside the database class, the `todos` getter has been created by moor.// loads all todo entriesFuture&amp;lt;List&amp;lt;Todo&amp;gt;&amp;gt; get allTodoEntries =&amp;gt; select(todos).get();// watches all todo entries in a given category. The stream will automatically// emit new items whenever the underlying data changes.Stream&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; watchEntriesInCategory(Category c) {  return (select(todos)..where((t) =&amp;gt; t.category.equals(c.id))).watch();}Select statementsYou can create select statements by starting them with select(tableName), where the table nameis a field generated for you by moor. Each table used in a database will have a matching fieldto run queries against. Any query can be run once with get() or be turned into an auto-updatingstream using watch().WhereYou can apply filters to a query by calling where(). The where method takes a function thatshould map the given table to an Expression of boolean. A common way to create such expressionis by using equals on expressions. Integer columns can also be compared with isBiggerThanand isSmallerThan. You can compose expressions using and(a, b), or(a, b) and not(a).LimitYou can limit the amount of results returned by calling limit on queries. The method acceptsthe amount of rows to return and an optional offset.OrderingYou can use the orderBy method on the select statement. It expects a list of functions that extract the individualordering terms from the table.Future&amp;lt;List&amp;lt;TodoEntry&amp;gt;&amp;gt; sortEntriesAlphabetically() {  return (select(todos)..orderBy([(t) =&amp;gt; OrderingTerm(expression: t.title)])).get();}You can also reverse the order by setting the mode property of the OrderingTerm toOrderingMode.desc.Updates and deletesYou can use the generated row class to update individual fields of any row:Future moveImportantTasksIntoCategory(Category target) {  // use update(...).write when you have a custom where clause and want to update  // only the columns that you specify (here, only &quot;category&quot; will be updated, the  // title and description of the rows affected will be left unchanged).  // Notice that you can't set fields back to null with this method.  return (update(todos)      ..where((t) =&amp;gt; t.title.like('%Important%'))    ).write(TodoEntry(      category: target.id    ),  );}Future update(TodoEntry entry) {  // using replace will update all fields from the entry that are not marked as a primary key.  // it will also make sure that only the entry with the same primary key will be updated.  // Here, this means that the row that has the same id as entry will be updated to reflect  // the entry's title, content and category. Unlike write, this supports setting columns back  // to null. As it set's its where clause automatically, it can not be used together with where.  return update(todos).replace(entry);}Future feelingLazy() {  // delete the oldest nine entries  return (delete(todos)..where((t) =&amp;gt; t.id.isSmallerThanValue(10))).go();}⚠️ Caution: If you don’t explicitly add a where clause on updates or deletes, the statement will affect all rows in the table!InsertsYou can very easily insert any valid object into tables:// returns the generated idFuture&amp;lt;int&amp;gt; addTodoEntry(Todo entry) {  return into(todos).insert(entry);}All row classes generated will have a constructor that can be used to create objects:addTodoEntry(  Todo(    title: 'Important task',    content: 'Refactor persistence code',  ),);If a column is nullable or has a default value (this includes auto-increments), the fieldcan be omitted. All other fields must be set and non-null. The insert method will throwotherwise.",
    "url": "/writing-queries/",
    "relUrl": "/writing-queries/"
  }
}
